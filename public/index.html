<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubik's Cubi</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <script type="module">
        // Import de la librairie
        import * as THREE from 'https://unpkg.com/three/build/three.module.js';
        import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js";

        // Fonction pour redimensionner la scène à la fenêtre
        function OnWindowResize() {
            let SCREEN_WIDTH = window.innerWidth;
            let SCREEN_HEIGHT = window.innerHeight;
            let ratioLargeurHauteur = SCREEN_WIDTH / SCREEN_HEIGHT;

            camera.aspect = ratioLargeurHauteur;
            camera.updateProjectionMatrix();

            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        }
        window.addEventListener("resize", OnWindowResize);

        // Création de la scène, de la caméra et du rendu
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Cube originel
        var geometryCube = new THREE.BoxGeometry(1, 1, 1);
        var materialCube1 = new THREE.MeshBasicMaterial({ color: 0xff8000, side: THREE.DoubleSide }); // Face avant - orange
        var materialCube2 = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide }); // Face arrière - rouge
        var materialCube3 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide }); // Face supérieure - blanc
        var materialCube4 = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide }); // Face inférieure - jaune
        var materialCube5 = new THREE.MeshBasicMaterial({ color: 0x0000ff, side: THREE.DoubleSide }); // Face gauche - bleu
        var materialCube6 = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide }); // Face droite - vert

        var cubeGroup = new THREE.Group();
        var cubeSize = 1.01;

        // Boucle pour créer tous les cubes
        for (let i = 0; i < 27; i++) {
            const cubeName = `cube${i}`;
            const cube = new THREE.Mesh(geometryCube, [materialCube1, materialCube2, materialCube3, materialCube4, materialCube5, materialCube6]);
            const x = (i % 3) * cubeSize;
            const y = Math.floor((i % 9) / 3) * cubeSize;
            const z = Math.floor(i / 9) * cubeSize;
            cube.position.set(x - cubeSize, y - cubeSize, z - cubeSize);
            cube.name = cubeName; // assigner le nom unique à la propriété "name" de l'objet cube
            cubeGroup.add(cube);
        }
        scene.add(cubeGroup);

        const cube0 = scene.getObjectByName("cube0"); // Groupes 1, 2, 5 & 6
        const cube1 = scene.getObjectByName("cube1"); // Groupes 1, 2, 5 & 6
        const cube2 = scene.getObjectByName("cube2"); // Groupes 1, 2, 5 & 6
        const cube3 = scene.getObjectByName("cube3"); // Groupes 2 & 6
        const cube4 = scene.getObjectByName("cube4"); // Centre
        const cube5 = scene.getObjectByName("cube5"); // Groupes 2 & 6
        const cube6 = scene.getObjectByName("cube6"); // Groupes 2 & 6
        const cube7 = scene.getObjectByName("cube7"); // Groupes 2, 3, 6 & 7
        const cube8 = scene.getObjectByName("cube8"); // Groupes 2 & 6
        const cube9 = scene.getObjectByName("cube9"); // Groupes 1 & 5
        const cube10 = scene.getObjectByName("cube10"); // Centre
        const cube11 = scene.getObjectByName("cube11"); // Groupes 1 & 5
        const cube12 = scene.getObjectByName("cube12"); // Centre
        const cube13 = scene.getObjectByName("cube13"); // Cube central
        const cube14 = scene.getObjectByName("cube14"); // Centre
        const cube15 = scene.getObjectByName("cube15"); // Groupes 3 & 7
        const cube16 = scene.getObjectByName("cube16"); // Centre
        const cube17 = scene.getObjectByName("cube17"); // Groupes 3 & 7
        const cube18 = scene.getObjectByName("cube18"); // Groupes 1 & 5
        const cube19 = scene.getObjectByName("cube19"); // Groupes 1 & 5
        const cube20 = scene.getObjectByName("cube20"); // Groupes 1 & 5
        const cube21 = scene.getObjectByName("cube21"); // Groupes 3 & 7
        const cube22 = scene.getObjectByName("cube22"); // Centre
        const cube23 = scene.getObjectByName("cube23"); // Groupes 4 & 8
        const cube24 = scene.getObjectByName("cube24"); // Groupes 3 & 7
        const cube25 = scene.getObjectByName("cube25"); // Groupes 3 & 7
        const cube26 = scene.getObjectByName("cube26"); // Groupes 2 & 6

        const group = new THREE.Group();
        const group1 = new THREE.Group();
        group.add(cube0, cube3, cube6, cube9, cube12, cube15, cube18, cube21, cube24);
        group1.add(cube2, cube5, cube8, cube11, cube14, cube17, cube20, cube23, cube26);
        scene.add(group, group1);

        // Rotations
        document.addEventListener('keydown', function (event) {
            // Groupe
            if (event.key === 'q') {
                var rotation = 0;
                var angleDegGauche = 90;
                var angleRadGauche = angleDegGauche * Math.PI / 180;
                var rotateSpeed = Math.PI / 180;

                function animateGroupCubeGauche() {
                    if (rotation < angleRadGauche) {
                        group.rotateX(rotateSpeed);
                        rotation += rotateSpeed;
                        requestAnimationFrame(animateGroupCubeGauche);
                    }
                }
                animateGroupCubeGauche();
            }
            if (event.key === 'd') {
                var rotation = 0;
                var angleDegDroite = -90;
                var angleRadDroite = angleDegDroite * Math.PI / 180;
                var rotateSpeed = Math.PI / 180;

                function animateGroupCubeDroite() {
                    if (rotation > angleRadDroite) {
                        group.rotateX(-rotateSpeed);
                        rotation -= rotateSpeed;
                        requestAnimationFrame(animateGroupCubeDroite);
                    }
                }
                animateGroupCubeDroite();
            }
            // Groupe 1
            if (event.key === 'a') {
                var rotation = 0;
                var angleDegGauche = 90;
                var angleRadGauche = angleDegGauche * Math.PI / 180;
                var rotateSpeed = Math.PI / 180;

                function animateGroupCubeGauche1() {
                    if (rotation < angleRadGauche) {
                        group1.rotateX(rotateSpeed);
                        rotation += rotateSpeed;
                        requestAnimationFrame(animateGroupCubeGauche1);
                    }
                }
                animateGroupCubeGauche1();
            }
            if (event.key === 'e') {
                var rotation = 0;
                var angleDegDroite = -90;
                var angleRadDroite = angleDegDroite * Math.PI / 180;
                var rotateSpeed = Math.PI / 180;

                function animateGroupCubeDroite1() {
                    if (rotation > angleRadDroite) {
                        group1.rotateX(-rotateSpeed);
                        rotation -= rotateSpeed;
                        requestAnimationFrame(animateGroupCubeDroite1);
                    }
                }
                animateGroupCubeDroite1();
            }
        });

        // Fonction utilitaire pour convertir les degrés en radians
        function toRadians(angle) {
            return angle * (Math.PI / 180);
        }

        // Contrôle de l'orbite
        const controls = new OrbitControls(camera, renderer.domElement);

        camera.position.set(-6, 4, -6);
        camera.lookAt(0, 0, 0);

        // Fonction d'affichage du rendu
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Tableau pour stocker les touches enfoncées
        const keys = {};

        // Fonction pour gérer les événements de clavier
        function onKeyDown(event) {
            keys[event.code] = true;
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        // Ajout des écouteurs d'événements de clavier
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        controls.update();
        renderer.render(scene, camera);

        animate();
    </script>
</body>

</html>