<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubik's Cubi</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <script type="module">
        // Import de la librairie
        import * as THREE from 'https://unpkg.com/three/build/three.module.js';
        import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js";

        // Fonction pour redimensionner la scène à la fenêtre
        function OnWindowResize() {
            let SCREEN_WIDTH = window.innerWidth;
            let SCREEN_HEIGHT = window.innerHeight;
            let ratioLargeurHauteur = SCREEN_WIDTH / SCREEN_HEIGHT;

            camera.aspect = ratioLargeurHauteur;
            camera.updateProjectionMatrix();

            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        }
        window.addEventListener("resize", OnWindowResize);

        // Création de la scène, de la caméra et du rendu
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Cube originel
        var geometryCube = new THREE.BoxGeometry(1, 1, 1);
        var materialCube1 = new THREE.MeshBasicMaterial({ color: 0xff8000, side: THREE.DoubleSide }); // Face avant - orange
        var materialCube2 = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide }); // Face arrière - rouge
        var materialCube3 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide }); // Face supérieure - blanc
        var materialCube4 = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide }); // Face inférieure - jaune
        var materialCube5 = new THREE.MeshBasicMaterial({ color: 0x0000ff, side: THREE.DoubleSide }); // Face gauche - bleu
        var materialCube6 = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide }); // Face droite - vert

        var cubeGroup = new THREE.Group();
        var cubeSize = 1.01;

        // Boucle pour créer tous les cubes
        for (let i = 0; i < 27; i++) {
            const cubeName = `cube${i}`;
            const cube = new THREE.Mesh(geometryCube, [materialCube1, materialCube2, materialCube3, materialCube4, materialCube5, materialCube6]);
            const x = (i % 3) * cubeSize;
            const y = Math.floor((i % 9) / 3) * cubeSize;
            const z = Math.floor(i / 9) * cubeSize;
            cube.position.set(x - cubeSize, y - cubeSize, z - cubeSize);
            cube.name = cubeName; // assigner le nom unique à la propriété "name" de l'objet cube
            cubeGroup.add(cube);
        }
        scene.add(cubeGroup);

        const cube0 = scene.getObjectByName("cube0"); // Groupes 1, 2, 5 & 6
        const cube1 = scene.getObjectByName("cube1"); // Groupes 1, 2, 5 & 6
        const cube2 = scene.getObjectByName("cube2"); // Groupes 1, 2, 5 & 6
        const cube3 = scene.getObjectByName("cube3"); // Groupes 2 & 6
        const cube4 = scene.getObjectByName("cube4"); // Centre
        const cube5 = scene.getObjectByName("cube5"); // Groupes 2 & 6
        const cube6 = scene.getObjectByName("cube6"); // Groupes 2 & 6
        const cube7 = scene.getObjectByName("cube7"); // Groupes 2, 3, 6 & 7
        const cube8 = scene.getObjectByName("cube8"); // Groupes 2 & 6
        const cube9 = scene.getObjectByName("cube9"); // Groupes 1 & 5
        const cube10 = scene.getObjectByName("cube10"); // Centre
        const cube11 = scene.getObjectByName("cube11"); // Groupes 1 & 5
        const cube12 = scene.getObjectByName("cube12"); // Centre
        const cube13 = scene.getObjectByName("cube13"); // Cube central
        const cube14 = scene.getObjectByName("cube14"); // Centre
        const cube15 = scene.getObjectByName("cube15"); // Groupes 3 & 7
        const cube16 = scene.getObjectByName("cube16"); // Centre
        const cube17 = scene.getObjectByName("cube17"); // Groupes 3 & 7
        const cube18 = scene.getObjectByName("cube18"); // Groupes 1 & 5
        const cube19 = scene.getObjectByName("cube19"); // Groupes 1 & 5
        const cube20 = scene.getObjectByName("cube20"); // Groupes 1 & 5
        const cube21 = scene.getObjectByName("cube21"); // Groupes 3 & 7
        const cube22 = scene.getObjectByName("cube22"); // Centre
        const cube23 = scene.getObjectByName("cube23"); // Groupes 4 & 8
        const cube24 = scene.getObjectByName("cube24"); // Groupes 3 & 7
        const cube25 = scene.getObjectByName("cube25"); // Groupes 3 & 7
        const cube26 = scene.getObjectByName("cube26"); // Groupes 2 & 6

        const group1 = new THREE.Group();
        group1.add(cube0, cube1, cube2, cube9, cube11, cube18, cube19, cube20);
        // const group2 = new THREE.Group();
        // group2.add(cube0, cube1, cube2, cube3, cube5, cube6, cube7, cube8);
        // const group3 = new THREE.Group();
        // group3.add(cube6, cube7, cube9, cube15, cube17, cube21, cube24, cube25, cube26);
        // const group4 = new THREE.Group();
        // group4.add(cube5, cube23, cube24, cube25, cube26);
        const group5 = new THREE.Group();
        group5.add(cube0, cube1, cube2, cube9, cube11, cube18, cube19, cube20);
        // const group6 = new THREE.Group();
        // group6.add(cube0, cube1, cube2, cube3, cube5, cube6, cube7, cube8);
        // const group7 = new THREE.Group();
        // group7.add(cube7, cube9, cube15, cube17, cube21, cube24, cube25, cube26);
        // const group8 = new THREE.Group();
        // group8.add();

        scene.add(group1, group5);

        // Ajout d'un événement de souris pour faire tourner le cube
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const rotateSpeed = 0.5;

        function onMouseMove(event) {
            // Calcul de la position de la souris en coordonnées normalisées (-1 à 1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Rotation du cube en fonction de la position de la souris
            if (isDragging) {
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };

                const deltaRotationQuaternion = new THREE.Quaternion()
                    .setFromEuler(new THREE.Euler(
                        toRadians(deltaMove.y * rotateSpeed),
                        toRadians(deltaMove.x * rotateSpeed),
                        0,
                        'XYZ'
                    ));

                cube10.quaternion.multiplyQuaternions(deltaRotationQuaternion, cube10.quaternion);
            }

            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseDown(event) {
            isDragging = true;
        }

        function onMouseUp(event) {
            isDragging = false;
        }

        // Ajout des écouteurs d'événements de la souris
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);

        // Fonction utilitaire pour convertir les degrés en radians
        function toRadians(angle) {
            return angle * (Math.PI / 180);
        }

        // Contrôle de l'orbite
        const controls = new OrbitControls(camera, renderer.domElement);

        camera.position.set(-6, 4, -6);
        camera.lookAt(0, 0, 0);

        // Fonction d'affichage du rendu
        function animate() {
            requestAnimationFrame(animate);
            const speed = 0.1;
            // Déplacement horizontal
            if (keys.ArrowRight) {
                cube6.position.x += speed;
            } else if (keys.ArrowLeft) {
                cube6.position.x -= speed;
            }

            // Déplacement vertical
            if (keys.ArrowUp) {
                cube6.position.y += speed;
            } else if (keys.ArrowDown) {
                cube6.position.y -= speed;
            }

            renderer.render(scene, camera);
        }

        // Tableau pour stocker les touches enfoncées
        const keys = {};

        // Fonction pour gérer les événements de clavier
        function onKeyDown(event) {
            keys[event.code] = true;
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        // Ajout des écouteurs d'événements de clavier
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        controls.update();
        renderer.render(scene, camera);

        animate();
    </script>
</body>

</html>